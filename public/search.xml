<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年7个月股市心得</title>
    <url>/2020/11/17/2020%E5%B9%B47%E4%B8%AA%E6%9C%88%E8%82%A1%E5%B8%82%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>​        片断时间经营股市7个月，有根据策略、母亲的指点、同学的意见等综合因素获利7000，收益炒25%，也有因吃到甜头反复操作单支股票导致翻车、贪婪不止损等因素亏损7000，截止今日7个月在金钱数额上的功夫时间化为泡影。因此做一定的心得总结，不一定有用，但是闲暇时候看一下也是对自己的一种警示。这次主要记录自己的问题，对于炒股学到的东西，我觉得自己初步尝试的一套逻辑具有一定的可行性，所以后续可以继续开展。果然数据分析能力比工程能力更重要。</p>
<h2 id="买股逻辑"><a href="#买股逻辑" class="headerlink" title="买股逻辑"></a>买股逻辑</h2><h3 id="短线"><a href="#短线" class="headerlink" title="短线"></a>短线</h3><p>​        中国股市太妖，因此短线和长线的炒法思路大有不同。短线炒股偏向技术炒股，企业业绩影响较小，更多是考虑主力资金的流形以及时事热点红利，股市蜡烛图中的5、10、15日线等情况以及各种指标，包括利好与利坏，超短线心态要端正和魄力感觉冲也要注意及时止损。短线炒的是红利股，上升股，因此追高策略可能更合适，在哪个点追高需要经验以及慎重考虑。</p>
<h3 id="长线"><a href="#长线" class="headerlink" title="长线"></a>长线</h3><p>​        长线更多是考虑耐心和对于国家产业布局的眼光和判断，例如5g和半导体长期来看是我国势必会发展的产业，具有长期投资价值，但是短线不一定具有高额回报盈利的可能性，因此抄底策略可能更合适，在合适的低点进入需要考虑。同时关注时事变化，疫情等突发事件的影响对于特定板块能带来喷发式的红利影响，因此对于天灾人祸等因素以及国际政治格局变化、科技产业打压变化等时事变化，不仅仅是悲天悯人，同时需要看到这些事件后相关产业的潜在机会。</p>
<h3 id="龙头股"><a href="#龙头股" class="headerlink" title="龙头股"></a>龙头股</h3><p>​        在炒热门板块时，并不是有机会去了解所有的股票，在没有特殊意外情况下，龙头股的业绩以及增长情况客观，如果可以尽量考虑购买龙头股，对于没有足够精力分析各个股票的我们来说相对会省力一些。</p>
<h3 id="上下游产业与产业概念"><a href="#上下游产业与产业概念" class="headerlink" title="上下游产业与产业概念"></a>上下游产业与产业概念</h3><p>​        上下游产业相当重要，与企业的业绩直接挂钩，因此上游产业的降价，下游产业的利好对于企业来说都是利好。同时产业概念与下游产业具有较高相关度，关注热门产业板块对于分析企业价值有用。</p>
<h3 id="指标分析"><a href="#指标分析" class="headerlink" title="指标分析"></a>指标分析</h3><p>​        目前我主要看的关键指标，企业总收益情况与总收益增长率，企业净利润增长率，美股净利润增长率。并非只要是增长就是好的，配合时事以及产业布局，有些增长率未达到预期对企业季度财报来说在一定程度上来说就是利空。</p>
<h2 id="买股心态"><a href="#买股心态" class="headerlink" title="买股心态"></a>买股心态</h2><p>​        我9、10、11月份的暴跌主要是由于吃到了几只股的甜头，进行重复操作，然而对于信息和局势的把握不准，导致最后一次买入买在了山顶导致后续雪崩时的亏损，因此即便是反复吃一只股的甜头也还是要及时关注相关新闻，不能因为经验去判断股价的波动振幅区间。</p>
<p>​        其次，及时止损是非常重要的手段，在亏损的股出现亏损的苗头的时候，我其实是有足够的时间抛售减持减低损失的，但是因为个人的盲目判断以及详细股价能回涨的贪婪心理，导致止损不及时，造成重大亏损。股市赚钱可以，但是还是要设置心理的收益上限，赌徒心理最终也只会带来亏损。</p>
<p>​        再者，平和的心态非常重要，在出现较大亏损的时候，我的心态就容易变得焦躁和慌乱，后续的买股就会变得盲目，缺少自己的主观判断，导致盲目跟风追高。还一方面也是因为时间经历有限，没有太多精力去研究股票变化。但是其实即便如此每天花在股市上的时间也不少。因此既然都这样了，不如花时间研究下个股的业绩和相关局势形式。高买低抛也是后续操作出现频繁亏损的一个重要原因，因此保持正常良好的心态非常重要。炒股目前阶段还是学习研究，也是锻炼心态的好时候。</p>
<p>​        近期小结如此，后续考虑写一下更细节的个股买卖思路。</p>
<p>流水：至11.19为止投入资金，其中9600是15年股本：</p>
<p>20年股本：4000+2000+3000 +1500+3500 +2000+3000 +1600+3000+4000=9000+5000+5000+4600+4000=9000+10000+8600=27600+2600+4000=34200</p>
<p>总股本：9600+34200=43600</p>
<p>20年初始股本5000+34200=39200</p>
<p>12月入股1500 总股本40700</p>
]]></content>
      <categories>
        <category>股市</category>
      </categories>
      <tags>
        <tag>股票</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习入门（一）</title>
    <url>/2021/03/31/Deep-learning/</url>
    <content><![CDATA[<p><strong>贝叶斯误差</strong></p>
<p>已知数据真实分布，预测出现的误差。在统计学中，是指针对任意分类器随机输出的最低可能误差。</p>
<p>例子：<strong>分布是真实的，但预测的输出只能是一个值，所以会有误差。</strong>例如，假设真实世界中90%长头发的人为女性，10%为男性（这是已知的真实分布）；此时已知一个人头发长，预测该同学性别。由于只能预测男/女。<strong>此时即使你知道真实分布，预测为女，也会有10%的误差。这就是贝叶斯误差。</strong></p>
<p><strong>正则化</strong></p>
<p>防止过拟合</p>
<p><a href="https://www.zhihu.com/question/20924039/answer/240037674" target="_blank" rel="noopener">https://www.zhihu.com/question/20924039/answer/240037674</a></p>
<p><img src="/2021/03/31/Deep-learning/image-20210331165434490.png" alt="image-20210331165434490"></p>
<p><img src="/2021/03/31/Deep-learning/image-20210331165819734.png" alt="image-20210331165819734"></p>
<p>加了正则项的损失函数Loss如上，求最小Loss的w。假设，w参数向量只有两个即w1，w2，以w1、w2为坐标，那么上述公式中前者拟合圆方程，后者为正则项（性状由次幂决定）。那么该损失函数最小值即求圆方程+正则项的最小值。在下图中，往往是两个图形的交点处。</p>
<p><img src="/2021/03/31/Deep-learning/image-20210331165927135.png" alt="image-20210331165927135"></p>
<p><strong>方差的无偏估计</strong></p>
<p>　　若估计量的数学期望存在，且期望等于未知参数，则称该估计量为参数的无偏估计量。</p>
<p>　　估计量的无偏性是指对于某些样本值来说，得到的估计量和真值相比，有的偏大，有的偏小，但就其平均而言，偏差为0。估计量的期望和真值相差被称为系统误差，无偏估计实际上是指无系统误差。</p>
<p><strong>均方误差MSE</strong></p>
<script type="math/tex; mode=display">
MSE=E[(θ ̂_m-θ)^2 ]=[Bias(θ ̂_m)]^2+Var(θ ̂_m)</script><p>等于贝叶斯误差+方差</p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210513215217220.png" alt="image-20210513215217220"></p>
<p>残差网络：</p>
<p>解决梯度消失问题：添加跳连接</p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210517205049715.png" alt="image-20210517205049715"></p>
<p>导致问题：梯度爆炸</p>
<p>深入：</p>
<p>1、理论角度理解</p>
<p>2、阅读pytorch文档（通读一遍）</p>
<p>3、复现经典工作（读写循环，自己写）</p>
<p>4、选择特定研究领域，阅读论文，研究框架，扩充视野</p>
<p>RNN（循环神经网络）专门用来处理带有序列模式的数据，需要使用权重共享，减少训练的数量。处理具有序列关系的数据。天气、股市、自然语言NLP</p>
<p>本质是线性层，与CNN的线性层的区别，是共享的</p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518104813940.png" alt="image-20210518104813940"></p>
<p>激活函数用tanh</p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518110322586.png" alt="image-20210518110322586"></p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518135023149.png" alt="image-20210518135023149"></p>
<p>第二种写法 </p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518150830731.png" alt="image-20210518150830731"></p>
<p>要求</p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518151805015.png" alt="image-20210518151805015"></p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518151850609.png" alt="image-20210518151850609"></p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518152015874.png" alt="image-20210518152015874"></p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518152056721.png" alt="image-20210518152056721"></p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518152114809.png" alt="image-20210518152114809"></p>
<p>自然语言处理思路流程：</p>
<p>第一步，字符级的，先根据字符构造字典，然后根据词典将数据变成索引，然后变成One-Hot向量。向量的列数与字典里字符的数量一直，</p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210518154337134.png" alt="image-20210518154337134"></p>
<p><img src="/2021/03/31/Deep-learning/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20210519152651271.png" alt="image-20210519152651271"></p>
<p>RNN+CNN计算损失</p>
<p>独热向量缺点：</p>
<p>1、维度太高</p>
<p>2、稀疏</p>
<p>3、硬编码，非学习</p>
<p>解决方法：嵌入层，即数据降维，矩阵转换？</p>
<p>输出大小与输入大小W，步长s，卷积核f，padding（P）关系</p>
<p><img src="/2021/03/31/Deep-learning/image-20210602093017862.png" alt="image-20210602093017862"></p>
<p><img src="/2021/03/31/Deep-learning/image-20210602094941161.png" alt="image-20210602094941161"></p>
]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>Deep learning, AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Skeletion paper notes</title>
    <url>/2020/11/12/Skeletion-paper-notes/</url>
    <content><![CDATA[<h1 id="Skeletonization-of-Plant-Point-Cloud-Data-Using-Stochastic-Optimization-Framework（有待进一步研究）"><a href="#Skeletonization-of-Plant-Point-Cloud-Data-Using-Stochastic-Optimization-Framework（有待进一步研究）" class="headerlink" title="Skeletonization of Plant Point Cloud Data Using Stochastic Optimization Framework（有待进一步研究）"></a>Skeletonization of Plant Point Cloud Data Using Stochastic Optimization Framework（有待进一步研究）</h1><p>问题：</p>
<p>Problems with the existing approaches on skeletonizing plant point cloud data. Original point cloud is shown as black point cloud and the skeleton points are shown as red points. (Left) The problem of zigzag structure, where the skeleton does not follow the centerline of the stem and tends to deviate toward the branching point (Xu et al., 2007) (only the main stem skeleton is shown in the figure). (Middle) The problem of biologically irrelevant skeleton points which falls beyond the boundary of the input data (shown at the top part), and inability to capture the geometric details for some branches (Delagrange et al., 2014; Ziamtsov and Navlakha, 2019). (Right) Overlooking tiny geometrical structures (Xu et al., 2007).</p>
<p>现有的关于植物点云数据框架化的方法存在问题： 原始点云显示为黑点云，骨架点显示为红点。 （左）锯齿形结构问题，即骨架不跟随茎的中心线，而倾向于向分支点偏移（Xu等，2007）（图中仅显示了主茎骨架）。 （中）生物学上不相关的骨架点超出输入数据的边界（显示在顶部）的问题，以及无法捕获某些分支的几何细节的问题（Delagrange等人，2014年; Ziamtsov和Navlakha，2019年） ）。 （右）俯瞰微小的几何结构（Xu等，2007）</p>
<p><img src="/2020/11/12/Skeletion-paper-notes/fpls-11-00773-g001.jpg" alt="img"></p>
<p>抛出三个问题：</p>
<p>①Z字型结构，需要解决的关键问题</p>
<p>②无效不不准确的骨架点计算：骨架点在数据外部；数量不足区域无法表示分支的实际情况，完全分支无法用骨架点表示，解决方法是用插值或点近似策略生成更多骨架点，</p>
<p>③细小分支被视为噪声</p>
<p>初始化骨架，然后参数化表示骨架，用图表示，由于节点突变，所以考虑节点曲率求导为0？随机建模方法有点难理解，需要时间</p>
<h1 id="An-Accurate-Skeleton-Extraction-Approach-From-3D-Point-Clouds-of-Maize-Plants"><a href="#An-Accurate-Skeleton-Extraction-Approach-From-3D-Point-Clouds-of-Maize-Plants" class="headerlink" title="An Accurate Skeleton Extraction Approach From 3D Point Clouds of Maize Plants"></a>An Accurate Skeleton Extraction Approach From 3D Point Clouds of Maize Plants</h1><p>Skeleton extraction from 3D plant point cloud data is an essential prior for myriads of phenotyping studies. Although skeleton extraction from 3D shapes have been studied extensively in the computer vision and graphics literature, handling the case of plants is still an open problem.</p>
<p>Drawbacks of the existing approaches include the zigzag structure of the skeleton, nonuniform density of skeleton points, lack of points in the areas having complex geometry structure, and most importantly the lack of biological relevance.</p>
<p>自适应采样：目的：确定关键点，保持分支的几何特性，在枝条的交点采用不同的球形半径采样技术</p>
<p>确定是否是交叉点，引入点的方向堵来描述线性趋势，就是协方差确定方向度量衡，跟L1这块做的思路一致</p>
<p>方法效果一般可借鉴思路：骨架点连接部分，如何剔除非同一骨架点连接的情况。以及修正骨架。</p>
<p>①该文章思路是认为局部骨架点能够成近似平面，根据点距离拟合平面的距离（并非简单的欧氏距离，是带有区里权重的一个参数）来判断点是否是在某个骨架分支上。（平面是一个借鉴思路，实际上我也这样做，但是问题是，很多时候并不是平面，因此得看具体数据做出判断）</p>
<p>②在骨架修正方面，该文章思路找垂直于某个骨架点切方向的平面然后，找到该切平面的聚类点集进行重新拟合骨架点。</p>
<h1 id="Knowledge-and-Heuristic-Based-Modelingof-Laser-Scanned-Trees"><a href="#Knowledge-and-Heuristic-Based-Modelingof-Laser-Scanned-Trees" class="headerlink" title="Knowledge and Heuristic-Based Modelingof Laser-Scanned Trees"></a>Knowledge and Heuristic-Based Modelingof Laser-Scanned Trees</h1><p>需要先验经验（手动选择模型根节点，或者模型严格满足平行xyz坐标系，选择最低点）</p>
<h1 id="TopoAngler-Interactive-Topology-based-Extraction-of-Fishes"><a href="#TopoAngler-Interactive-Topology-based-Extraction-of-Fishes" class="headerlink" title="TopoAngler: Interactive Topology-based Extraction of Fishes"></a>TopoAngler: Interactive Topology-based Extraction of Fishes</h1><p>对CT鱼群的扫描进行自动化的分割识别</p>
<p>instead of forcing the user to detect fishes in the dataset and manually construct bounding boxes, our system makes use of a hierarchical segmentation to find features of interest in the dataset</p>
<p>通过分级分割获取数据特征</p>
<h1 id="Towards-“smart-canopy”-sorghum-discovery-of-the-genetic-control-of-leaf-angle-across-layers"><a href="#Towards-“smart-canopy”-sorghum-discovery-of-the-genetic-control-of-leaf-angle-across-layers" class="headerlink" title="Towards “smart canopy” sorghum: discovery of the genetic control of leaf angle across layers"></a>Towards “smart canopy” sorghum: discovery of the genetic control of leaf angle across layers</h1><p>顶部直立，底部平铺，最大程度提高光的拦截和转换效率，增产</p>
<p>角度分布室内室外与基因型相反？（室内外不一致？）</p>
]]></content>
      <categories>
        <category>3DReconstruction</category>
      </categories>
      <tags>
        <tag>几何, 三维重建, 植物</tag>
      </tags>
  </entry>
  <entry>
    <title>Skeleton connect</title>
    <url>/2020/12/04/Skeleton-connect/</url>
    <content><![CDATA[<p><img src="/2020/12/04/Skeleton-connect/image-20201204145335371.png" alt="image-20201204145335371"></p>
<p><img src="/2020/12/04/Skeleton-connect/image-20201204145348872.png" alt="image-20201204145348872"></p>
<p><img src="/2020/12/04/Skeleton-connect/image-20201204173319000.png" alt="image-20201204173319000"></p>
<p>问题1：通过距离进行约束的时候发现由于骨架点太多，导致邻域骨架在连接时存在重复问题，所以要进行resample</p>
<p>多个连接点问题：</p>
<p>投影距离计算有误？</p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213000554273.png" alt="image-20201213000554273"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213000612305.png" alt="image-20201213000612305"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213000627972.png" alt="image-20201213000627972"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213000718596.png" alt="image-20201213000718596"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001129943.png" alt="image-20201213001129943"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001143264.png" alt="image-20201213001143264"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001215416.png" alt="image-20201213001215416"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001253017.png" alt="image-20201213001253017"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001312082.png" alt="image-20201213001312082"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001318727.png" alt="image-20201213001318727"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001343659.png" alt="image-20201213001343659"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001354098.png" alt="image-20201213001354098"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001407471.png" alt="image-20201213001407471"></p>
<p><img src="/2020/12/04/Skeleton-connect/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201213001441061.png" alt="image-20201213001441061"></p>
]]></content>
      <categories>
        <category>3DReconstruction</category>
      </categories>
      <tags>
        <tag>几何, 三维重建, 植物</tag>
      </tags>
  </entry>
  <entry>
    <title>三维表型--网格孔洞识别填补(二)————缺陷孔洞识别</title>
    <url>/2019/05/01/fill-Holes/</url>
    <content><![CDATA[<h1 id="缺陷孔洞识别"><a href="#缺陷孔洞识别" class="headerlink" title="缺陷孔洞识别"></a>缺陷孔洞识别</h1><h2 id="缺陷孔洞与非缺陷孔洞区别-借鉴思路"><a href="#缺陷孔洞与非缺陷孔洞区别-借鉴思路" class="headerlink" title="缺陷孔洞与非缺陷孔洞区别-借鉴思路"></a>缺陷孔洞与非缺陷孔洞区别-借鉴思路</h2><p>之前孔洞识别将所有封闭换都识别出来，但是存在的问题是，本身是封闭的正常部分也被识别，因此需要通过将两者区分开来；下图中都为所有孔洞，第三幅图中底部的圆孔为非缺陷孔洞，需要剔除。</p>
<p><img src="/2019/05/01/fill-Holes/多种孔洞情况.jpg" alt="多种孔洞情况"></p>
<p><strong>缺陷孔洞的检测方法思路</strong></p>
<p>从孔洞的几何特性进行区分：</p>
<p>①周边表面不规则性；</p>
<p>②轮廓曲线不规则性；</p>
<p>步骤</p>
<p>1、通过曲率估计的方法对孔洞轮廓周边的点集进行聚类，表示方式有高斯曲率、平均曲率（这两者不一定适合），形状索引<a href="https://www.sciencedirect.com/science/article/pii/026288569290076F" title="形状索引" target="_blank" rel="noopener">1</a>，是范围（-1，+ I）中的数字，是尺度不变的。形状指数特别好地捕捉了“局部形状”的直观概念。形状指数可以映射到直观的自然色标。形状索引用于描述曲面上任意点在表面领域二极结构的一种方法：</p>
<p><img src="/2019/05/01/fill-Holes/公式1.png" alt="公式1"></p>
<p>周边聚类的质心i的形状索引为：</p>
<p><img src="/2019/05/01/fill-Holes/公式2.png" alt="公式2"></p>
<p>2、通过对轮廓曲线的曲率与扭力两个几何特性进行区分。通过测量轮廓的切向量变化来判断是否为缺陷孔洞；</p>
<p>文章里说缺陷孔洞的切线变化是杂乱无章的，非缺陷孔洞在切线角度上的变化是平滑过渡的。</p>
<p><img src="/2019/05/01/fill-Holes/缺陷孔洞.png" alt="缺陷孔洞"></p>
<p><img src="/2019/05/01/fill-Holes/切线与法线分布.png" alt="切线与法线分布"></p>
<h2 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h2><p>植株的实际情况不同：</p>
<p><img src="/2019/05/01/fill-Holes/实际孔洞情况.png" alt="实际孔洞情况"></p>
<p>小型孔洞（多为缺陷孔洞，如上图-右）个点法向量较为一致，差异较小；</p>
<p>大型孔洞（如上图-中）法向量部分超圆内，部分朝圆外，差异较大；</p>
<p>按照上述思路，通过法向量差异进行判断，那么法向量差异小的为缺陷孔洞，法向量差异大的为非缺陷孔洞；</p>
<p>思路：依次获取孔洞个点的法向量，并比较向量两点法向量的角度差，即每条边两个顶点的角度差，计算平均角度差与标准角度偏差，小于设定阈值为缺陷孔洞，否则不为缺陷孔洞</p>
<p>伪码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;vertex&gt;&gt;holes_out;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;holes.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;angleall;</span><br><span class="line">    <span class="keyword">double</span> sumangle=getangle(holes.at(i).at(<span class="number">0</span>),holes.at(i).at(holes.size()<span class="number">-1</span>));</span><br><span class="line">    angleall.push_back(sumangle);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;holes.at(i).size()<span class="number">-1</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> tempangle=getangle(holes.at(j).at(<span class="number">0</span>),holes.at(i).at(j+<span class="number">1</span>));</span><br><span class="line">        sumagle += tempangle;</span><br><span class="line">        angleall.push_back(tempangle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> aveangle=sumangle/holes.at(i).siez();</span><br><span class="line">    <span class="keyword">double</span> Nrmse2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;angleall.size();k++)</span><br><span class="line">    &#123;</span><br><span class="line">        Nrmse2+=(angleall.at(k)-aveangle)*(angleall.at(k)-aveangle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> rmse=<span class="built_in">sqrt</span>(Nrmse2*<span class="number">1.0</span>/angleall.size());</span><br><span class="line">    <span class="keyword">if</span>(rmse&lt;threshold1 &amp;&amp; aveangle &lt;threshold2)</span><br><span class="line">    &#123;</span><br><span class="line">        holes_out.pushback(holes.at(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>设定平均角度阈值为0.4（22.9°），rmse阈值为0.5</p>
<p><img src="/2019/05/01/fill-Holes/ave0.4-rmse0.5.png" alt="ave0.4-rmse0.5"></p>
<p>设定平均角度阈值为0.2（11.45°），rmse阈值为0.5</p>
<p><img src="/2019/05/01/fill-Holes/ave0.2-rmse0.5_2.png" alt="ave0.2-rmse0.5_2"></p>
<p>设定平均角度阈值为0.4（22.9°），rmse阈值为0.3</p>
<p><img src="/2019/05/01/fill-Holes/ave0.4-rmse0.3.png" alt="ave0.4-rmse0.3"></p>
<p>设定平均角度阈值为0.6（33.4°），rmse阈值为0.3</p>
<p><img src="/2019/05/01/fill-Holes/ave0.6-rmse0.3.png" alt="ave0.6-rmse0.3"></p>
<p>设定平均角度阈值为0.6（33.4°），rmse阈值为0.1</p>
<p><img src="/2019/05/01/fill-Holes/ave0.6-rmse0.1.png" alt="ave0.6-rmse0.1"></p>
<p>设定平均角度阈值为0.4（22.9°），rmse阈值为0.3</p>
<p>因此，平均角度阈值与rmse阈值对于孔洞有一定效果</p>
<p>但是仍存在一些问题：不封闭孔洞，以及半边数据构成的孔洞实际为单独的面片结构。</p>
<h1 id="相关引申资料概念"><a href="#相关引申资料概念" class="headerlink" title="相关引申资料概念"></a>相关引申资料概念</h1><h3 id="平均形状概念"><a href="#平均形状概念" class="headerlink" title="平均形状概念"></a>平均形状概念</h3><p>基于形状索引特征的平均值</p>
<h3 id="形状索引特征概念"><a href="#形状索引特征概念" class="headerlink" title="形状索引特征概念"></a>形状索引特征概念</h3><p>一种特征描述子，与形状相关，可有曲率、法向量等信息表示；</p>
<h2 id="图形特征"><a href="#图形特征" class="headerlink" title="图形特征"></a>图形特征</h2><h3 id="对象识别特征"><a href="#对象识别特征" class="headerlink" title="对象识别特征"></a>对象识别特征</h3><p>1、对于类间变化敏感，有效区分对象与背景；</p>
<p>2、类内不变形，对同一个对象在不同的角度、光照、表情（人体）、弯曲情况（植株叶片）的变化具有一定的不不变性。手工特征：Gabor，LBP，SIFT；无监督学习：LE；</p>
<h3 id="导数表"><a href="#导数表" class="headerlink" title="导数表"></a>导数表</h3><p><img src="/2019/05/01/fill-Holes/导数表.png" alt="导数表"></p>
]]></content>
      <categories>
        <category>3DReconstruction</category>
      </categories>
      <tags>
        <tag>几何, 三维重建, 植物</tag>
      </tags>
  </entry>
  <entry>
    <title>农业三维重建应用框架</title>
    <url>/2019/07/22/%E5%86%9C%E4%B8%9A%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="农业领域三维技术应用"><a href="#农业领域三维技术应用" class="headerlink" title="农业领域三维技术应用"></a>农业领域三维技术应用</h1><h2 id="一、区分"><a href="#一、区分" class="headerlink" title="一、区分"></a>一、区分</h2><h3 id="1、应用场景区分："><a href="#1、应用场景区分：" class="headerlink" title="1、应用场景区分："></a>1、应用场景区分：</h3><p>①农业机械化作业应用：</p>
<p>机械化机具的重建——机具的修复改进；</p>
<p>作物对象精细重建——用于识别、分选、筛选；</p>
<p>②植物表型研究应用：<br>作物对象重建——主要是获取结构信息：植株骨架、叶片面积，用于不同目的研究（例如生长周期结构变化研究，结构模型与光照分布等信息的研究以及动力学模型结构结合研究）；</p>
<p>③动物形态研究：</p>
<p>类似植物表型；</p>
<p>④农业作业大场景范围重建：</p>
<p>农田、果园、森林等环境重建——用于农机、无人机等设备导航、遥感数据分析等；</p>
<h3 id="2、应用设备区分"><a href="#2、应用设备区分" class="headerlink" title="2、应用设备区分"></a>2、应用设备区分</h3><p>①双目视觉、多目视觉；</p>
<p>②深度相机（消费级）；</p>
<p>③结构光相机；</p>
<p>④激光雷达；</p>
<p>⑤三维扫描仪（基于结构光、激光，基于三角测距原理、基于飞行时间原理）；</p>
<h2 id="二、技术路线"><a href="#二、技术路线" class="headerlink" title="二、技术路线"></a>二、技术路线</h2><p>主要从点云层面说明，基于视觉原理的检测方法最终目的还是获取点云，因此点云数据的处理与分析是与各种研究应用直接相关；</p>
<h3 id="Step1：点云采集与预处理"><a href="#Step1：点云采集与预处理" class="headerlink" title="Step1：点云采集与预处理"></a>Step1：点云采集与预处理</h3><p>（视觉方法目的就是完成该步骤中的点云采集）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>精度</th>
<th>操作便携性</th>
<th>采集算法难度</th>
<th>成本</th>
<th>问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>视觉方法</td>
<td>高</td>
<td>相对复杂</td>
<td>复杂</td>
<td>低</td>
<td>噪声和点云质量受算法影响大</td>
</tr>
<tr>
<td>深度相机</td>
<td>低</td>
<td>适中</td>
<td>简单</td>
<td>低</td>
<td>点云质量低，噪声大</td>
</tr>
<tr>
<td>结构光相机</td>
<td>高</td>
<td>便携-适中</td>
<td>适中</td>
<td>高</td>
<td>受环境光影响大</td>
</tr>
<tr>
<td>激光扫描仪</td>
<td>高</td>
<td>便携-适中</td>
<td>简单</td>
<td>高</td>
<td>只能获取点云信息，且大多需贴点处理</td>
</tr>
</tbody>
</table>
</div>
<p>预处理目的——提高点云质量，包括（下列几点无先后顺序）：</p>
<p>①降噪：采用平滑算法、滤波算法、采集时重复采用取平均等方法消除点云高频噪声、离群噪声、飞行点噪声等；</p>
<p>②背景剔除：仅保留目标对象点云；</p>
<h3 id="Step2：点云数据配准"><a href="#Step2：点云数据配准" class="headerlink" title="Step2：点云数据配准"></a>Step2：点云数据配准</h3><p>该步骤主要目的是将多个不同视角下的点云统一到同一个坐标系下；且该步骤对于需要进行多角度情况需要进行重建，对于单角度应用情况非必须步骤；</p>
<p>主要步骤分为<br>1、粗配准：快速的配准方法，减少对应点的旋转、平移差距，为精配准服务；</p>
<p>步骤：计算特征子，寻找特征子点集的对应点集，并计算旋转、平局矩阵；</p>
<p>经典算法：基于FPFH的粗配准；</p>
<p>算法具体：</p>
<p>2、精配准：准确的配准方法；</p>
<p>步骤：对于所有点进行匹配，使得满足目标函数最小化，迭代过程是收敛的；</p>
<p>经典算法：ICP算法及其变种算法；</p>
<p>算法具体：</p>
<h3 id="Step3：点云优化"><a href="#Step3：点云优化" class="headerlink" title="Step3：点云优化"></a>Step3：点云优化</h3><p>经过配准后的点云数据存在：点云数量大，点云密集，配准后存在噪声，点云分层等问题，需要进一步优化；优化的思路：具体问题具体分析；</p>
<p><strong>点云数量大，点云密集：</strong>降采样，体素格采样等；</p>
<p><strong>配准后存在噪声：</strong>离群滤波处理，平滑算法处理等；</p>
<p><strong>分层现象：</strong>特定算法处理；</p>
<h3 id="Step4：点云基础上的多种处理"><a href="#Step4：点云基础上的多种处理" class="headerlink" title="Step4：点云基础上的多种处理"></a>Step4：点云基础上的多种处理</h3><p>1、网格处理：使点云数据面片化，建立点与点之间的拓扑关系，可使其后续可计算面积信息、添加纹理信息等；</p>
<p>具体算法：Delauney三角化网格算法、贪婪三角化网格方法、posson网格等；</p>
<p>Delauney网格方法思路具体介绍：</p>
<p>2、骨架提取：点云核心结构的提取，简并数据；</p>
<p>单一骨架可以反馈植株的结构性状，从而研究叶倾角等信息；</p>
<p>对于动物而言，骨架课反馈动物动作变化等信息，实现动物行为检测等；</p>
<p>方法思路具体介绍：</p>
<p>3、对象分割识别：</p>
<h3 id="Step5：实际应用具体分析"><a href="#Step5：实际应用具体分析" class="headerlink" title="Step5：实际应用具体分析"></a>Step5：实际应用具体分析</h3><p>农业领域该技术通常都是辅助技术，因此该技术的应用都是需要结合具体问题进行；</p>
]]></content>
      <categories>
        <category>3DReconstruction</category>
      </categories>
      <tags>
        <tag>三维重建, 植物</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/12/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>深度学习-三维点云-植物表型</title>
    <url>/2019/11/12/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91-%E6%A4%8D%E7%89%A9%E8%A1%A8%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="主要提取的点云特征："><a href="#主要提取的点云特征：" class="headerlink" title="主要提取的点云特征："></a>主要提取的点云特征：</h1><h2 id="一、主曲率"><a href="#一、主曲率" class="headerlink" title="一、主曲率"></a>一、主曲率</h2><p>点在平面的移动速度，陡峭程度；</p>
<p>计算方式：</p>
<p>Step1：pj(px, py, pz)点的法向量nj(nx, ny, nz)投影到法向量ni(nix, niy, niz)和点pi(pix, piy, piz)构成的切平面，pj是pi的领域点：</p>
<p>切平面表示：nix (x-pix) + niy (y-piy) + niz (z-piz)=0;</p>
<p>各点法向量投影表示：<img src="/2019/11/12/深度学习-三维点云-植物表型/1573521660696.png" alt="1573521660696"></p>
<p>其中，I是3×3的单位矩阵；</p>
<p>注:向量 $\vec{n_i} \bigotimes \vec{n_i}$表示两法向量直积，但是个人认为这里应该是发现了的列向量直积列向量转置，否则无法得到3×3的单位矩阵，最后得到矩阵a应该是:</p>
<script type="math/tex; mode=display">{ }
a = \left[
\matrix{
nix·nix & nix·niy & nix·niz \\
niy·nix & niy·niy & niy·niz \\
niz·nix & niz·niy & niz·niz \\
}
\right] 
$$ { }
I-a得到矩阵</script><p>a = \left[<br>\matrix{<br>1-nix·nix &amp; nix·niy &amp; nix·niz \<br>niy·nix &amp; 1-niy·niy &amp; niy·niz \<br>niz·nix &amp; niz·niy &amp; 1-niz·niz \<br>}<br>\right]</p>
<script type="math/tex; mode=display">
得到投影向量$\vec{m}$=</script><p>\matrix{<br>(1-nix·nix)·nx+nix·niy·ny+nix·niz·nz,\<br>niy·nix·nx+(1-niy·niy)·ny+niy·niz·nz,\<br>niz·nix·nz+niz·niy·ny+(1-niz·niz)·nz, \<br>}</p>
<p>$$<br>然后计算协方差的特征向量得到三个λ，则通过大小排序可得到最大与最小曲率以及曲率方向</p>
<p><img src="/2019/11/12/深度学习-三维点云-植物表型/1573525802291.png" alt="1573525802291"></p>
<h1 id="二、半径表面特征"><a href="#二、半径表面特征" class="headerlink" title="二、半径表面特征"></a>二、半径表面特征</h1><p>得到设定半径内，领域点与计算点的法线夹角与亮点距离，这两个统一作为一个特征；</p>
<h1 id="三、PFH点特征直方图"><a href="#三、PFH点特征直方图" class="headerlink" title="三、PFH点特征直方图"></a>三、PFH点特征直方图</h1><p>加快的还有FPFH</p>
<h1 id="四、SHOT-方向直方图特征"><a href="#四、SHOT-方向直方图特征" class="headerlink" title="四、SHOT 方向直方图特征"></a>四、SHOT 方向直方图特征</h1><p>Signature of histogram of orientations</p>
<p>构造方法：以查询点p为中心构造半径为r 的球形区域，沿径向、方位、俯仰3个方向划分网格，其中径向2次，方位8次（为简便图中径向只划分了4个），俯仰2次划分网格，将球形区域划分成32个空间区域。在每个空间区域计算计算落入该区域点的法线nv和中心点p法线np之间的夹角余弦cosθ=nv·np，再根据计算的余弦值对落入每一个空间区域的点数进行直方图统计，对计算结果进行归一化，使得对点云密度具有鲁棒性，得到一个352维特征。（原论文：Unique Signatures of Histograms for Local Surface）<br><img src="/2019/11/12/深度学习-三维点云-植物表型/1573528340406.png" alt="1573528340406"></p>
<h1 id="五、Spin-image旋转图像"><a href="#五、Spin-image旋转图像" class="headerlink" title="五、Spin image旋转图像"></a>五、Spin image旋转图像</h1><p><a href="https://blog.csdn.net/renyuanxingxing/article/details/83279328" target="_blank" rel="noopener">https://blog.csdn.net/renyuanxingxing/article/details/83279328</a></p>
<p>三维点云深度学习分类</p>
<p><img src="/2019/11/12/深度学习-三维点云-植物表型/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201219234147873.png" alt="image-20201219234147873"></p>
<h1 id="PointNet-amp-PointNet"><a href="#PointNet-amp-PointNet" class="headerlink" title="PointNet&amp;PointNet++"></a>PointNet&amp;PointNet++</h1><h3 id="PointNet的问题"><a href="#PointNet的问题" class="headerlink" title="PointNet的问题"></a>PointNet的问题</h3><p>PointNet对每个点表征，未考虑点邻域信息，局部信息描述不足；maxpooling最后提取的是全局特征，损失较多信息；分割网络是将点特征与全局特征拼接，描述能力有限。</p>
<p>PointNet++中用到了FPS最远点降采样，相比随机降采样的优势：尽肯能广泛考虑覆盖空间中的所有点（包括噪声）</p>
<p>Point++中的Group layer寻找领域点是在坐标空间进行，采用的是KNN或者query ball point,并没有考虑特征空间的相似性。</p>
<p>Query ball更加适合于应用在局部/细节识别的应用上，比如局部分割。</p>
<h3 id="PointNet-和PointNet的区别在于"><a href="#PointNet-和PointNet的区别在于" class="headerlink" title="PointNet++和PointNet的区别在于:"></a>PointNet++和PointNet的区别在于:</h3><p>类比CNN，pointnet可以看做一个卷积层，因为他通过max pooling后考虑的是整个点集的全局特征。若果这个点集是全体点集的一部分，那么可以发现PointNet与CNN的卷积核类似。而PN++则是在此基础上考虑了局部的信息，并对分层局部特征进行了整合。</p>
<p>其中，在Point Layer层，主要分为了三个步骤</p>
<p>1)point feature embedding</p>
<p>2)pooling in local regions</p>
<p>3)further processing</p>
<p>其中，步骤1是进行特征维度调整，将多维特征（x,y,z,nx,ny,nz, 其中n为法向量)等通过1×1的卷积核进行线性组合实现升维或者降维，从而达到嵌套的目的；步骤2是以某点P为中心,将邻域点的特征信息进行整合来描述该点P的局部特征，这里用的是pooling（可以是，max，mean等）。继续做1×1的卷积，这个步骤论文没有用，实际上也没有必要，因为这个时候的数据就是最远点采样后的点及特征，继续将这些采用点整合的话，又变成一个全局性的，尺度在此变大。当然考虑到多个尺度的可以卷积，但是1×1的卷积如果不非线性变化的话没有太大的意义。</p>
<p>点云深度学习借用的先验知识有限；</p>
]]></content>
      <categories>
        <category>3DReconstruction</category>
      </categories>
      <tags>
        <tag>三维重建, 植物</tag>
      </tags>
  </entry>
  <entry>
    <title>琐事2020.10.28</title>
    <url>/2020/10/28/%E7%90%90%E4%BA%8B2020-10-2888/</url>
    <content><![CDATA[<p>今天终于搞定了繁琐的文档工作，开题报告，读书报告。</p>
<p>最怕自己的行为给别人的生活带来不好的影响。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活，思考</tag>
      </tags>
  </entry>
  <entry>
    <title>生活-学习</title>
    <url>/2020/10/27/%E7%94%9F%E6%B4%BB-%E5%AD%A6%E4%B9%A0-%E7%88%B1%E6%83%85/</url>
    <content><![CDATA[<p>本来想把这个个人主页做成技术站，现实是技术突破太慢，久久难以更新。嗨，反正是个人主页，想放什么放什么，也无所谓了。也是想来很久没写东西，近期生活枯燥而波动，个人情绪始终不是特别的高昂，稍稍记录一下。</p>
<p><strong>有关学习</strong></p>
<p>​        学习是我唯一坚持这么多年的事，但是实际上读研之后，更多的是在赶工赶进度，做导师的项目，完成导师的任务，一年下来真正静下心来好好学习的时间寥寥无几。也不全怪导师，从小到大一直在区域拔尖的学校学习，多多少少有点自傲。浮躁，焦虑，伴随我3年半的情绪始终是影响个人工作状态的两大因素，挥之不去。所幸，现实打脸的很快，我也不过是平平常常的普通人，膨胀的状态没有维持多久变气馁了下来，自信心挫败的感觉并不好受。每个人对生活的都有本质的态度，表面上的乐观并无法改变骨子里的悲观。所幸我认为人要死的有价值，所以我怕死，至少不会干出自杀这种事。这种不负责，不仁义。也所幸认识了子毅师兄。目前，还是慢慢找状态，沉静下来心来去学。社会很浮躁，适应社会却很违背本心，不适应社会又难以生存。也只能学习了。</p>
<p><strong>有关生活</strong></p>
<p>​        今年是特殊的一年，疫情毕业，再次感受到了别离。可能是上了年纪，以前是对到一个新的地方充满期待，现在则是希望一群朋友就呆在一个地方温馨和谐。但是生活别离才是常态。嗨，毕业的同学们，有机会再聚。小两级的师弟师妹们充满了活力，是青春的力量，偶尔跟他们一起活动感觉到了年轻的感觉。明明只大了2级，大概两三岁的样子，心态感觉就和他们差了好多。可能我适合安居一隅吧。很让我感动的是王唯师姐，让我感受到亲姐的感觉，很贴心很细心，少有的感动。生活还是这样波澜不惊，以前挺喜欢杭州的，但可能是因为这群朋友，现在朋友都陆陆续续开始他们新的人生了。我对杭州腻了。</p>
<p><strong>关于股票</strong></p>
<p>​        半年时间，收益从25%跌倒10%不到，贪婪是难以消除的劣根性，把期待寄托于市场以及他人的建议，不如自己研究制定良好的买卖策略，亏本不急躁，盈利不贪婪，在股市里保持良好的操盘心态。</p>
<p>​        学习室的空气还是一样的闷热，坐久了就会让我头脑发胀，身边的人还是忙碌着。依旧是等待着毕业，等待着明天。</p>
<p>​        一片杂文，没有逻辑，只是记录。</p>
<p>​        嗨，好久没用博客了，忘记怎么上传了，又得折腾一点时间 = =。</p>
]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>生活，思考</tag>
      </tags>
  </entry>
  <entry>
    <title>三维表型--聚类分割</title>
    <url>/2020/10/29/%E8%81%9A%E7%B1%BB%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<p>坐标xyz，RGB颜色，HSV空间颜色信息</p>
<p>使用HSV色彩空间的有点是其每个属性都直接对应于基本色彩概念，这使得它在图像处理中变得简单</p>
<p>三角植被指数，对于植株点云的分割：</p>
<script type="math/tex; mode=display">
TGI=-0.5×[0.19(R-G)-0.12(R-B)]</script><p>Hog3D</p>
<p>kmeans聚类</p>
<h2 id="特征向量缩放"><a href="#特征向量缩放" class="headerlink" title="特征向量缩放"></a>特征向量缩放</h2><p>正定矩阵和半正定矩阵</p>
<p>正定矩阵：给定一个大小为 <img src="https://www.zhihu.com/equation?tex=n%5Ctimes+n" alt="[公式]"> 的实对称矩阵 <img src="https://www.zhihu.com/equation?tex=A" alt="[公式]"> ，若对于任意长度为 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 的非零向量 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D" alt="[公式]"> ，有 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%5ETA%5Cboldsymbol%7Bx%7D%3E0" alt="[公式]"> 恒成立，则矩阵 <img src="https://www.zhihu.com/equation?tex=A" alt="[公式]"> 是一个正定矩阵</p>
<p>半正定矩阵：给定一个大小为 <img src="https://www.zhihu.com/equation?tex=n%5Ctimes+n" alt="[公式]"> 的实对称矩阵 <img src="https://www.zhihu.com/equation?tex=A" alt="[公式]">，若对于任意长度为 <img src="https://www.zhihu.com/equation?tex=n" alt="[公式]"> 的向量 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D" alt="[公式]"> ，有 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%5ETA%5Cboldsymbol%7Bx%7D%5Cgeq0" alt="[公式]"> 恒成立，则矩阵 <img src="https://www.zhihu.com/equation?tex=A" alt="[公式]"> 是一个半正定矩阵</p>
<p>直观解释：</p>
<p>若给定任意一个正定矩阵 <img src="https://www.zhihu.com/equation?tex=A%5Cin%5Cmathbb%7BR%7D%5E%7Bn%5Ctimes+n%7D" alt="[公式]"> 和一个非零向量 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%5Cin%5Cmathbb%7BR%7D%5E%7Bn%7D" alt="[公式]"> ，则两者相乘得到的向量 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7By%7D%3DA%5Cboldsymbol%7Bx%7D%5Cin%5Cmathbb%7BR%7D%5E%7Bn%7D" alt="[公式]"> 与向量 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D" alt="[公式]"> 的夹角恒小于 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpi%7D%7B2%7D" alt="[公式]"> . (等价于： <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%5ETA%5Cboldsymbol%7Bx%7D%3E0" alt="[公式]"> .)</p>
<p>若给定任意一个半正定矩阵 <img src="https://www.zhihu.com/equation?tex=A%5Cin%5Cmathbb%7BR%7D%5E%7Bn%5Ctimes+n%7D" alt="[公式]"> 和一个向量 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%5Cin%5Cmathbb%7BR%7D%5E%7Bn%7D" alt="[公式]"> ，则两者相乘得到的向量 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7By%7D%3DA%5Cboldsymbol%7Bx%7D%5Cin%5Cmathbb%7BR%7D%5E%7Bn%7D" alt="[公式]"> 与向量 <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D" alt="[公式]"> 的夹角恒小于或等于 <img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpi%7D%7B2%7D" alt="[公式]"> . (等价于： <img src="https://www.zhihu.com/equation?tex=%5Cboldsymbol%7Bx%7D%5ETA%5Cboldsymbol%7Bx%7D%5Cgeq0" alt="[公式]"> .)</p>
<p>协方差矩阵的特征向量控制旋转(rotation)，特征值控制尺度(scale)，</p>
]]></content>
      <categories>
        <category>3DReconstruction</category>
      </categories>
      <tags>
        <tag>几何, 三维重建</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/28/%E8%AE%BA%E6%96%87%E6%94%B9%E7%A8%BF/</url>
    <content><![CDATA[<p><img src="/2020/12/28/论文改稿/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201228165046884.png" alt="image-20201228165046884"></p>
<p>1、The problem formulation should be highlighted.<br>2、The reviewer advise that the author could show their algorithm by a flow chart.<br>3、Does the author mean that Fig 3 (c)  and (a) represent the parallel and intersect relationship, (b) represents that the triangles are neither parallel nor intersect?</p>
<p><img src="/2020/12/28/论文改稿/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201228165304909.png" alt="image-20201228165304909"></p>
<p>1.- Manuscript only shows the results for one plant. It would be better to introduce different capture scenarios. If not, you should indicate / explain in both the title and the text that these are preliminary results.<br>2.- The results are shown as a set of tables and figures without a detailed explanation, you should rewrite this section completely.<br>3.- You should indicate the processing time used. My experiences and what other colleagues have told me is that you have millions of points that make it a long time-processing.<br>4.- Can it be used in a real case? your results only show a plant in a laboratory, far from what would be a test outdoors.</p>
<p><strong>Manuscript:</strong><br>5.- Introduction does not describe active and passive sensors. It should make this difference. Furthermore, within the passive ones they should introduce references and show the state of the art of these sensors.<br>6.- There are figures with different sub-indices that are not referenced in the text. For example in figure 1, the sub-figure 1.a should be linked in the sentence “The Kinect v2 was about…”. Keep this comment in mind for the whole document. In addition, you should use the template document where the number of lines appears for better review.<br>At the end of section 2.2.1 add a reference to Geomagic Studio.<br>7.- Section 2.2.3, add references in definitions 1, 2 and 3 to figure 3.<br>8.- Sorry, I do not understand what is meant in the text by abc and mnq.<br>9.- Table 1. Indicate in the test number the algorithm used.<br>10.- Figure 4 is not referenced in the text.<br>11.- Figures 4 and 5 are not well explained in the text.<br>12.- Table 2, same comment as in Table 1.<br>13.- Figure 6. The title of the figure is a little chaotic and difficult to understand.<br>14.- Table 3, same comment as in Table 1.<br>15.- In your conclusions you wrote that the proposed method offers accurate data  of plants. In this sense it must be taken into account that the test is not a real scenario of a crop. Thus:<br>a) How do you think the use of this method in a crop can affect your results?<br>b) How can it affect having a non-plain and constant background?<br>c) What is the influence of having different plants lined up?</p>
<p><img src="/2020/12/28/论文改稿/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201229205306088.png" alt="image-20201229205306088"></p>
]]></content>
  </entry>
  <entry>
    <title>论文与汇报注意点</title>
    <url>/2018/12/12/%E8%AE%BA%E6%96%87%E4%B8%8E%E6%B1%87%E6%8A%A5%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
    <content><![CDATA[<h1 id="英文展示注意"><a href="#英文展示注意" class="headerlink" title="英文展示注意"></a>英文展示注意</h1><p>1、图的效果讲下就够，不一定要详细描述图的细节</p>
<p>2、highlight重要的词</p>
<p>3、英文冒号用的不多</p>
<p>4、中英文标点符号统一</p>
<p>5、ppt字号英文24及以上，中文18及以上</p>
<p>6、英文报告ppt字体选择  arial  或者calibri</p>
<p>6、字体颜色不要花里胡哨，常规一点</p>
<p>7、放一张大的图，一个标题或一句话说明图的内容(在有很多图类似图的情况下)</p>
<p>8、<strong>研究意义、创新性是最重要的</strong></p>
<p>9、</p>
<h1 id="论文写作注意"><a href="#论文写作注意" class="headerlink" title="论文写作注意"></a>论文写作注意</h1><h2 id="英文摘要部分"><a href="#英文摘要部分" class="headerlink" title="英文摘要部分"></a>英文摘要部分</h2><p>1、根据不同期刊，字数要求注意；</p>
<p>2、</p>
]]></content>
      <categories>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>论文写作, 汇报注意</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/01/07/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%AD%A6(%E4%B8%89)/</url>
    <content><![CDATA[<p>以下的股有我妈以及我哥推荐的也有和几个炒股同学共同研究的。</p>
<p><strong>光伏以及新能源：</strong></p>
<p>这段时间大涨，短期有回调风险，长期看好，考虑到碳中和，全球气候协议这些国际政策因素</p>
<p><strong>上游产业</strong>:</p>
<p>601012，隆基股份，龙头一，目前113.55，入场存在风险，但是目前给我一种科技股中的茅台的感觉；</p>
<p>600438 通威股份，光伏硅片龙头二，理由和隆基一致，</p>
<p>002459 ，晶澳科技，也是光伏龙头之一，不过近期走势不如上面两个，</p>
<p><strong>中下游：</strong></p>
<p>300274，阳光电源，太阳能风能相关设备研发</p>
<p>002008，大族激光，激光加工设备研发，光伏设备研发；</p>
<p>000155，川能动力，太阳能风能发电</p>
<p><strong>基金</strong></p>
<p>515970，光伏EFT，光伏场内第一支基金，后续我看到可能还有515971会上市，目前价格只有1.242，考虑到长期以及风险因素，可以考虑该场内基金，反正场内基金和股票交易模式一样，不存在延时。</p>
<p>光伏目前涨挺好，不过最近主力资金有撤离，虽然感觉短期即便回调也有还是会反弹回涨，但是不好说啥时候机构撤资，师兄你不太常看的话不一定适合，长期一定看好，短期可以等回调低点买入（不确定时间）</p>
<p><strong>新能源汽车：</strong></p>
<p>515700，新能车ETF，3月份上市，目前2.3，走势与光伏ETF一直，新能源汽车有前景，但是目前涨的太凶，有风险可尝试。</p>
<p>000049，德赛电池，锂电池封装相关，我妈推荐关注，我没有深入了解</p>
<p><strong>化工：</strong>未进行深入了解，不过了解到有一部分原因是锂电池、光伏产业等原材料供应以及工业、服装业等行业的材料需求：</p>
<p>603799 华友钴业，近期曲线非常好，锂电池材料供应相关</p>
<p>002601 龙蟒佰利，钛白粉，这个貌似与服装行业也有关（我室友家里搞服装行业相关的，说这个有用的，加上年底供应</p>
<p>600456 宝钛股份，近期曲线也非常好，钛和钛合金相关研发</p>
<p>600309 万华化学，绩优股，同学昨天推荐想买，目前还没了解，不过近期曲线确实挺好</p>
<p><strong>食品和消费</strong>：（我表哥比较看好这个，他主买白酒，靠近年关，食品近期确实涨的很好）</p>
<p>600298，安琪酵母，国内唯一上市酵母公司，考虑到疫情居家，酵母使用量增大，起码在国内上市公司来说，酵母独一家，算是一定程度的垄断。</p>
<p>002507，涪陵榨菜，榨菜第一股，绩优股</p>
<p>300999，金龙鱼，近期曲线极好，99快关注，这几天已经涨到了139了</p>
<p>白酒我哥买，但是因为我不买酒所以白酒股没关注</p>
<p><strong>近期热点</strong></p>
<p>近期军工股涨势不错，貌似轰20要出了，然后相关的产业都长得挺好，</p>
<p>重点是在于</p>
<p>600760中航沈飞和002129中航光电，这两个貌似与轰20有较大联系</p>
<p>其他军工类似002625光启科技这种有张有跌。</p>
<p>目前总体股市感觉抄底难，只能买一些震荡股，或者追高涨的好的股，不少古跌下来后就回不去。</p>
]]></content>
  </entry>
  <entry>
    <title>证券投资学(一)</title>
    <url>/2020/12/06/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%AD%A6(%E4%B8%80)/</url>
    <content><![CDATA[<p>构建公司估值体系，行业分析方法</p>
<p>1、PE，市盈</p>
<p>2、年复合收益率=PEG=PE/主营业务利润增长率=PE/净利润增长率</p>
<p>PEG&lt;0.5无脑买入阶段，&lt;1就是安全边际内</p>
<p>可买入股票，20%主营业务增长，20%净资产收益率，30%一下资产负债比率，以及行业情况</p>
<p>3、基本分析</p>
<p>宏观，行业，公司</p>
<p>A股75%情绪影响，25%公司绩效影响</p>
<p>大盘整体PE的65左右时，基本到股市头部；</p>
<p>4、投资带来的经济增长存在结构性问题：</p>
<p>数据解读，20%投资增长带来10%经济增长</p>
<p>5、投资过剩，需要去场能、库存、杠杆</p>
<p>6、道氏理论-技术分析：</p>
<p>主要趋势，次级趋势，短暂趋势</p>
<p>3-5年，3-5个月（半年），3-5天</p>
<p>7、产业资本减持，金融资本投入——股市拐点</p>
<p>8、<img src="/2020/12/06/证券投资学(一)/证券投资学/image-20201202191020958.png" alt="image-20201202191020958"></p>
<p>9、国债收益率下滑，债券价格上扬</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>股票</tag>
      </tags>
  </entry>
  <entry>
    <title>三维表型--骨架提取</title>
    <url>/2019/07/12/%E9%AA%A8%E6%9E%B6%E6%8F%90%E5%8F%96/</url>
    <content><![CDATA[<h1 id="骨架提取"><a href="#骨架提取" class="headerlink" title="骨架提取"></a>骨架提取</h1><p>骨架提取的几种核心思路：</p>
<p>寻找约束中心，收缩领域模型（网格或是点云），体素格+八叉树细致划分</p>
<p>L1-骨架提取方法：</p>
<p>生成随机中心（此处用体素格降采样得到初始骨架中心代替）</p>
<p>正则化处理，邻域检索做文章</p>
<p>收敛过度是问题，如何改善可以做文章</p>
<p>现有结果：</p>
<p><img src="/2019/07/12/骨架提取/image-20201028151235620.png" alt="image-20201028151235620"></p>
<p><img src="/2019/07/12/骨架提取/image-20201028151248962.png" alt="image-20201028151248962"></p>
<p><img src="/2019/07/12/骨架提取/image-20201028151258843.png" alt="image-20201028151258843"></p>
<p><img src="/2019/07/12/骨架提取/image-20201028151306930.png" alt="image-20201028151306930"></p>
<p><img src="/2019/07/12/骨架提取/image-20201028151322133.png" alt="image-20201028151322133"></p>
<video src="骨架提取/0.5h-1.5h.mp4"></video>

<p><img src="/2019/07/12/骨架提取/image-20201101090333626.png" alt="image-20201101090333626"></p>
<p>最后一张是官方的和我的，黑色是我的骨架，红色的官方骨架，明显我的更好</p>
<p>数据结构：</p>
<p><img src="/2019/07/12/骨架提取/image-20201101104046646.png" alt="image-20201101104046646"></p>
<p><img src="/2019/07/12/骨架提取/image-20201101104102407.png" alt="image-20201101104102407"></p>
<p>改进分割</p>
<p><img src="/2019/07/12/骨架提取/image-20201109143747994.png" alt="image-20201109143747994"></p>
<p><img src="/2019/07/12/骨架提取/image-20201110092537670.png" alt="image-20201110092537670"></p>
]]></content>
      <categories>
        <category>3DReconstruction</category>
      </categories>
      <tags>
        <tag>几何, 三维重建</tag>
      </tags>
  </entry>
  <entry>
    <title>证券投资学(二)</title>
    <url>/2020/12/06/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%AD%A6(%E4%BA%8C)/</url>
    <content><![CDATA[<p>技术性熊市：两个季度内下跌幅度超过20%</p>
<p><img src="/2020/12/06/证券投资学(二)/证券投资学(二" alt="image-20201206152828283">/image-20201206152828283.png)</p>
<p>一级熔断后暂停15分钟，又开启</p>
<p>二级熔断后暂停15分钟，又开启</p>
<p>一级和二级一天只处罚一次，若二级熔断后只要不超过三级都不影响交易</p>
<p>三级熔断后，股市当天交易停止</p>
<p>期望收益率R=无风险收益率+风险溢价(风险补偿)</p>
<p>10年期国债当做无风险收益率去吃30 </p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>股票</tag>
      </tags>
  </entry>
  <entry>
    <title>三维表型--网格孔洞识别填补(一)————孔洞识别</title>
    <url>/2019/04/22/Note1/</url>
    <content><![CDATA[<h1 id="半边排序-填补孔洞"><a href="#半边排序-填补孔洞" class="headerlink" title="半边排序-填补孔洞"></a>半边排序-填补孔洞</h1><h3 id="记录如何得到半边的逻辑"><a href="#记录如何得到半边的逻辑" class="headerlink" title="记录如何得到半边的逻辑"></a>记录如何得到半边的逻辑</h3><p>根据delauney算法，若一条边最多被两个面共用，若一条边只被共用一次那么即为半边，只有半边可以形成孔洞，需要定义边类型，和半边类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myedge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> p1id;</span><br><span class="line">	<span class="keyword">int</span> p2id;</span><br><span class="line">	<span class="keyword">int</span> edge_times = <span class="number">0</span>;<span class="comment">// the use times of this edge;</span></span><br><span class="line">	<span class="keyword">int</span> edge_valid = <span class="number">0</span>;<span class="comment">// edge_valid = 0， edge is valid, otherwise  invalid;</span></span><br><span class="line">	myedge();</span><br><span class="line">	myedge(<span class="keyword">int</span> p1, <span class="keyword">int</span> p2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"Wrong edge!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">			edge_valid = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (p1 &gt; p2) &#123;</span><br><span class="line">			p1id = p2;</span><br><span class="line">			p2id = p1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			p1id = p1;</span><br><span class="line">			p2id = p2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> myedge &amp;x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">this</span>-&gt;p1id == x.p1id) &amp;&amp; (<span class="keyword">this</span>-&gt;p2id) == x.p2id)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>先三角化方法得到初步的网格数据vertics，然后转化为边类型<br>此处需要定义默认构造函数和重载==，因为边的两个点的顺序不确定，因此重载==时即考虑边相等时，两个情况都得考虑</p>
<p>注意：这里面半边数据结构集中的每个点最多使用两次，若要形成封闭的缺口，那么一定每个点使用两次</p>
<p>通过收入所有三角网格的边，并以端点<v1,v2>的形式保存，v1&lt;v2,然后计数每条边出现的次数，出现一次的为半边，其余的都为非半边删除</v1,v2></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameEdge</span><span class="params">(myedge e1, myedge e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e1.p1id == e2.p1id&amp;&amp;e1.p2id == e2.p2id)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInfront</span><span class="params">(myedge e1, myedge e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e1.p1id == e2.p1id)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (e1.p2id &lt;= e2.p2id)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (e1.p1id &lt; e2.p1id)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get half edges，and save into vector</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHalfEdge</span><span class="params">(PolygonMesh &amp;mesh1, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;myedge&gt; &amp;halfedges_out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// get halfedge;</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;myedge&gt; halfedges;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mesh1.polygons.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> p1 = mesh1.polygons.at(i).vertices[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> p2 = mesh1.polygons.at(i).vertices[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> p3 = mesh1.polygons.at(i).vertices[<span class="number">2</span>];</span><br><span class="line">		<span class="function">myedge <span class="title">e1</span><span class="params">(p1, p2)</span></span>;</span><br><span class="line">		<span class="function">myedge <span class="title">e2</span><span class="params">(p2, p3)</span></span>;</span><br><span class="line">		<span class="function">myedge <span class="title">e3</span><span class="params">(p3, p1)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (e1.edge_valid == <span class="number">0</span>)</span><br><span class="line">			halfedges.push_back(e1);</span><br><span class="line">		<span class="keyword">if</span> (e2.edge_valid == <span class="number">0</span>)</span><br><span class="line">			halfedges.push_back(e2);</span><br><span class="line">		<span class="keyword">if</span> (e3.edge_valid == <span class="number">0</span>)</span><br><span class="line">			halfedges.push_back(e3);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;myedge&gt;::iterator begin_pos = halfedges.begin();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;myedge&gt;::iterator end_pos = halfedges.end();</span><br><span class="line">	<span class="built_in">std</span>::sort(halfedges.begin(), halfedges.end(), isInfront);</span><br><span class="line">	<span class="comment">// above process is to get all edges(includeing halfedges and whole edges) and take them in order</span></span><br><span class="line">	<span class="comment">// if the edgd showed twice, it is not the halfedges</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;myedge&gt; halfedges_copy;</span><br><span class="line">	halfedges_copy = halfedges;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;myedge&gt;::iterator new_end = <span class="built_in">std</span>::unique(halfedges.begin(), halfedges.end(), isSameEdge);</span><br><span class="line">	halfedges.erase(new_end, end_pos);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Counts</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; halfedges.size() - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> begin_temp =</span><br><span class="line">			find(halfedges_copy.begin(), halfedges_copy.end(), halfedges.at(i));</span><br><span class="line">		<span class="keyword">auto</span> end_temp =</span><br><span class="line">			find(halfedges_copy.begin(), halfedges_copy.end(), halfedges.at(i + <span class="number">1</span>));</span><br><span class="line">		halfedges.at(i).edge_times = end_temp - begin_temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get halfedges</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; halfedges.size() - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (halfedges.at(i).edge_times == <span class="number">1</span>)</span><br><span class="line">			halfedges_out.push_back(halfedges.at(i));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; halfedges_out.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="检索孔洞逻辑"><a href="#检索孔洞逻辑" class="headerlink" title="检索孔洞逻辑"></a>检索孔洞逻辑</h2><p>步骤：</p>
<p>1、通过邻接表保存半边</p>
<p>2、通过递归的方式剔除半边中的端点，即不能形成闭环的点，即只被一条边共用的端点；</p>
<p>3、识别孔洞</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> recursion_times = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteEndPoint</span><span class="params">(Lgraph gp, <span class="keyword">int</span> searchsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Recursion times is: "</span> &lt;&lt; recursion_times &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; deleteID;</span><br><span class="line">	<span class="comment">// 由于find的得到的是第几个节点，因此得到n还需+1，因此链表下标从0开始</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; searchsize; i1++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = getlen(gp-&gt;G[i1]);</span><br><span class="line">		<span class="keyword">if</span> (len==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			deleteID.push_back(i1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (deleteID.size() != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deleteID.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">5485</span>; j &lt; searchsize; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">int</span> len = getlen(gp-&gt;G[j]);<span class="comment">//当邻接表表长为0的时候说明是空表，</span></span><br><span class="line">				<span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">auto</span> temp = delete_Vertex(deleteID.at(i), gp-&gt;G[j].FirstEdge);</span><br><span class="line">				gp-&gt;G[j].FirstEdge = temp;</span><br><span class="line">				gp-&gt;G[deleteID.at(i)].FirstEdge = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="comment">/*if (gp-&gt;G[j].FirstEdge-&gt;Next == NULL)</span></span><br><span class="line"><span class="comment">					gp-&gt;G[j].FirstEdge = NULL;*/</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		recursion_times++;</span><br><span class="line">		DeleteEndPoint(gp, searchsize);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHolesmap</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;myedge&gt; &amp;halfedges, Lgraph &amp;ph, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;holemap2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// save sa adjacent list</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pts;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; halfedges.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pts.push_back(halfedges.at(i).p1id);</span><br><span class="line">		pts.push_back(halfedges.at(i).p2id);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(pts.begin(), pts.end());</span><br><span class="line">	pts.erase(unique(pts.begin(), pts.end()), pts.end());</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> searchSize = FindMaxValue(pts);</span><br><span class="line"></span><br><span class="line">	Lgraph graph;</span><br><span class="line">	graph = CreatGraph(pts.size());</span><br><span class="line">	graph-&gt;Ne = halfedges.size();</span><br><span class="line">	<span class="keyword">if</span> (graph-&gt;Ne != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph-&gt;Ne; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			InsertEdge(graph, halfedges.at(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete end point using recursion</span></span><br><span class="line">	DeleteEndPoint(graph, searchSize);</span><br><span class="line">	ph = graph;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lens;</span><br><span class="line">	<span class="keyword">int</span> len4 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> len6 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; searchSize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> lentep = getlen(ph-&gt;G[i]);</span><br><span class="line">		<span class="keyword">if</span> (lentep != <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			lens.push_back(lentep);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">continue</span>;;</span><br><span class="line">		<span class="keyword">if</span> (lentep == <span class="number">4</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			len4++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (lentep == <span class="number">6</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			len6++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of points have 4 adjacent points: "</span> &lt;&lt; len4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of points have 6 adjacent points: "</span> &lt;&lt; len6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在得到孔洞的半边数据后，由于有些点被共用多次，如下图所示</p>
<p><img src="/2019/04/22/Note1/hole_situation2.jpg" alt="hole_situation"></p>
<ol>
<li>情况1表示孔洞所有点只被共用2次；</li>
<li>情况2表示孔洞红色点被共用4次，其余点被共用2次；</li>
<li>情况3表示孔洞红色点被共用6次，其余点被共用2次；</li>
<li>情况4表示多种情况混合，即图中红色点分别被共用6,4次（也可能存在4（4,4），（6,6）等情况的发生），其余点被共用2次；</li>
</ol>
<p>因此在采用深度优先搜索算法时需要进行分情况说明，伪码描述为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;node&gt;&gt; holes;</span><br><span class="line">DFS_hole(vertex v,<span class="built_in">vector</span>&lt;node&gt; out)<span class="comment">//此处仅考虑len=2的情况</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> len=getlen(V); <span class="comment">//获取节点后面的长度，长度为2,4,6</span></span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">2</span>)<span class="comment">//若这个节点长度是2，说明该节点被4条边共用，属于情况1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v.visit==<span class="number">0</span>)<span class="comment">//visit=0说明该节点还未访问过，添加到输出vector out中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>.push_back(v);</span><br><span class="line">            v.visit++;</span><br><span class="line">            v=v.nest;</span><br><span class="line">            DFS_hole(v,out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//visit=1说明该节点已经被访问，且又回到该节点，那说明该节点是起点且又回到起点，则out里一定有一个闭环，则holes中添加该闭环，并退出梯柜</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v.visit==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            holes.push_back(out);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果访问≥1次，在len=2时不存在这种情况，所以直接return；</span></span><br><span class="line">        <span class="comment">//不存在的原因时候len=4或len=6时会在生成一个闭环时终止递归，因此对于所有len=2的点最多只可能变量2次</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文仅考虑len=2时的情况，即情况1的情况，然而实际情况中是存在2,3,4三种情况，因此在执行上述深度优先搜索算法提取空洞前，先考虑将这些复杂情况的孔洞情况删除，即从邻接表中删除这些节点并保存至另一复杂孔洞的领接表中，伪码描述为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//形参：检索起始节点，输入图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_complex_holes</span><span class="params">(vnode v, Lgraph listin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//因为进入这个递归过程中的点，都是复杂情况下的闭环的点，因此标记这些点为复杂闭环圈；</span></span><br><span class="line">    <span class="comment">//标记完后递归</span></span><br><span class="line">    adjacentlist w;</span><br><span class="line">    v.isComplex=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=v.firstedge;w;w=w-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w.next.isComplex==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs_complex_holes(listin-&gt;g[w.vertex],listin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_complex_holes</span><span class="params">(Lgraph listin，<span class="keyword">int</span> searchtimes，Lgraph listout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>（<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;searchtimes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> len=getlen(listin-&gt;v[i]);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将遍历点都从复杂点开始，即被共用次数为4,6等，除0外</span></span><br><span class="line">            <span class="keyword">if</span>(len!=<span class="number">2</span>)</span><br><span class="line">                dfs_complex_holes(listin-&gt;g[i],listin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目代码，可运行Ver1.0：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记含有复杂点的闭环圈，即圈内存在被共用次数＞2的点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_complex_holes</span><span class="params">(Vnode v, Lgraph listin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//因为进入这个递归过程中的点，都是复杂情况下的闭环的点，因此标记这些点为复杂闭环圈；</span></span><br><span class="line">	<span class="comment">//标记完后递归</span></span><br><span class="line">	PtrToAdjVnode w;</span><br><span class="line">	<span class="keyword">if</span> (v.isComplex==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		listin-&gt;G[v.id].isComplex = <span class="number">1</span>;<span class="comment">// v.isComplex = 1;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (w = v.FirstEdge; w!=<span class="literal">NULL</span>; )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> temp = listin-&gt;G[w-&gt;AdjV];</span><br><span class="line">		<span class="keyword">if</span> ((listin-&gt;G[w-&gt;AdjV].isComplex == <span class="number">0</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			dfs_complex_holes(listin-&gt;G[w-&gt;AdjV], listin);</span><br><span class="line">			<span class="keyword">if</span> (w-&gt;Next == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				w = w-&gt;Next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (w-&gt;Next == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				w = w-&gt;Next;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取复杂点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_complex_holes</span><span class="params">(Lgraph listin, <span class="keyword">int</span> searchtimes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; searchtimes; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len = getlen(listin-&gt;G[i]);</span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//将遍历点都从复杂点开始，即被共用次数为4,6等，除0外</span></span><br><span class="line">			<span class="keyword">if</span> (len != <span class="number">2</span>)</span><br><span class="line">				dfs_complex_holes(listin-&gt;G[i], listin);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先搜索检索孔洞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_hole</span><span class="params">(Vnode v, Lgraph listin, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vnode&gt; &amp;out,</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vnode&gt;&gt; &amp;holes)</span><span class="comment">//此处仅考虑len=2的情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果该节点是复杂点，则不进入搜索闭环的环节；</span></span><br><span class="line">	<span class="keyword">if</span> (v.isComplex==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> len = getlen(v); <span class="comment">//获取节点后面的长度，长度为2,4,6</span></span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">2</span>)<span class="comment">//若这个节点长度是2，说明该节点被4条边共用，属于情况1</span></span><br><span class="line">	&#123;</span><br><span class="line">		PtrToAdjVnode w;</span><br><span class="line">		<span class="keyword">if</span> (v.Visited==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			listin-&gt;G[v.id].Visited = <span class="number">1</span>;</span><br><span class="line">			out.push_back(v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (w = v.FirstEdge; w != <span class="literal">NULL</span>; )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (listin-&gt;G[w-&gt;AdjV].Visited == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				DFS_hole(listin-&gt;G[w-&gt;AdjV], listin, out, holes);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (w-&gt;Next == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				w = w-&gt;Next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取正常孔洞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_holes</span><span class="params">(Lgraph ph, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vnode&gt;&gt; &amp;holes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxVertexuUm; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vnode&gt; temp;</span><br><span class="line">		DFS_hole(ph-&gt;G[i], ph, temp, holes);</span><br><span class="line">		<span class="keyword">if</span> (temp.size()!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			holes.push_back(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>识别效果如下：对于正常孔洞已经能较好的识别，但是存在将最外边界的点即形成封闭的叶片轮廓的点也识别为孔洞；同时还有一些其他的面片也易被识别为孔洞，后续需要根据几何性质进行情况分析。</p>
<p><img src="/2019/04/22/Note1/hole3.png" alt="hole3"></p>
<p>下一章主要为填补孔洞</p>
<p>豪斯多夫距离Hausdorff distance of convex polygons这部分没看完，先空着，与评估方法效果有关</p>
]]></content>
      <categories>
        <category>3DReconstruction</category>
      </categories>
      <tags>
        <tag>几何, 三维重建, 植物</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/12/20/%E8%AF%81%E5%88%B8%E6%8A%95%E8%B5%84%E5%AD%A6(%E4%BA%8C)/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<p><img src="/2020/12/20/证券投资学(二)/未命名/C:/Users\zhihong\AppData\Roaming\Typora\typora-user-images\image-20201217232004639.png" alt="image-20201217232004639"></p>
<p><img src="/2020/12/20/证券投资学(二)/未命名/C:/Users\zhihong\AppData\Roaming\Typora\typora-user-images\image-20201217233644690.png" alt="image-20201217233644690"></p>
<p><img src="/2020/12/20/证券投资学(二)/未命名/C:/Users\zhihong\AppData\Roaming\Typora\typora-user-images\image-20201218001311840.png" alt="image-20201218001311840"></p>
<p><img src="/2020/12/20/证券投资学(二)/未命名/C:/Users\zhihong\AppData\Roaming\Typora\typora-user-images\image-20201218005022454.png" alt="image-20201218005022454"></p>
<p><img src="/2020/12/20/证券投资学(二)/未命名/C:/Users\zhihong\AppData\Roaming\Typora\typora-user-images\image-20201218005353749.png" alt="image-20201218005353749"></p>
<p><img src="/2020/12/20/证券投资学(二)/未命名/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201223100344458.png" alt="image-20201223100344458"></p>
<p><img src="/2020/12/20/证券投资学(二)/未命名/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201223100406981.png" alt="image-20201223100406981"></p>
<p><img src="/2020/12/20/证券投资学(二)/未命名/C:/Users/zhihong/AppData/Roaming/Typora/typora-user-images/image-20201223100353454.png" alt="image-20201223100353454"></p>
]]></content>
  </entry>
</search>
